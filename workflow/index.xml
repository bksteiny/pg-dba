<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Index on pg-dba</title>
    <link>http://jonstacks.github.io/pg-dba/</link>
    <description>Recent content in Index on pg-dba</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 26 Mar 2019 02:51:12 -0600</lastBuildDate>
    
	<atom:link href="http://jonstacks.github.io/pg-dba/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Motivation</title>
      <link>http://jonstacks.github.io/pg-dba/intro/motivation/</link>
      <pubDate>Tue, 26 Mar 2019 14:40:22 -0500</pubDate>
      
      <guid>http://jonstacks.github.io/pg-dba/intro/motivation/</guid>
      <description>The motivation for pg-dba is to automate Postgres administation. We often found that our tables were becoming bloated and the number of dead tuples was large despite our best efforts at using the auto_vacuum and auto_analyze features of postgres.
Furthermore, we often found ourselves running a SQL script to find the tables that were bloated and then selectively running FULL VACUUM on them. Some tables are just too large to run a FULL VACUUM on since it would lock the table for too long and take down an app for too long.</description>
    </item>
    
    <item>
      <title>Diagram</title>
      <link>http://jonstacks.github.io/pg-dba/workflow/diagram/</link>
      <pubDate>Tue, 26 Mar 2019 14:38:07 -0500</pubDate>
      
      <guid>http://jonstacks.github.io/pg-dba/workflow/diagram/</guid>
      <description>Below is a simple diagram that shows the pg-dba workflow:
graph LR A[START] A -- B subgraph preanalyze B{&#34;PRE_ANALYZE=True?&#34;} B --|Yes| C[Run Analyze] end B --|No| D C -- D D[Run Query to check for table bloat] D--E[&#34;Vacuum table if bloated and not too large&#34;] E -- F subgraph postanalyze F{&#34;POST_ANALYZE=True?&#34;} F -- |Yes| G[Run Analyze] end F --|No| H G -- H H[STOP]  </description>
    </item>
    
  </channel>
</rss>